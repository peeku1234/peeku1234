package com.sbi.yb.services.service.impl;

import com.sbi.yb.services.cache.ReferenceDataCache;
import com.sbi.yb.services.constants.UtilsConstant;
import com.sbi.yb.services.repository.HolidayMasterDAO;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.LocalDateTime;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class CutoffTimeServiceTest {

    @Mock
    private HolidayMasterDAO holidayMasterDAO;

    @Mock
    private ReferenceDataCache referenceDataCache;

    @InjectMocks
    private CutoffTimeService cutoffTimeService;

    private Map<String, String> cutoffMap;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);

        cutoffMap = new HashMap<>();
        cutoffMap.put("RTGS_CUTOFF_START_TIME_SBI", "09:00");
        cutoffMap.put("RTGS_CUTOFF_END_TIME_SBI", "17:00");
        cutoffMap.put("RTGS_SAT_CUTOFF_START_TIME_SBI", "09:00");
        cutoffMap.put("RTGS_SAT_CUTOFF_END_TIME_SBI", "13:00");

        cutoffMap.put("NEFT_CUTOFF_START_TIME_SBI", "08:00");
        cutoffMap.put("NEFT_CUTOFF_END_TIME_SBI", "19:00");
        cutoffMap.put("NEFT_SAT_CUTOFF_START_TIME_SBI", "08:00");
        cutoffMap.put("NEFT_SAT_CUTOFF_END_TIME_SBI", "12:00");

        when(referenceDataCache.getCutOffTime()).thenReturn(cutoffMap);
    }

    @Test
    void testIsValidDateAndTime_HolidayFound() {
        LocalDateTime date = LocalDateTime.of(2025, 10, 14, 10, 0);
        Map<String, Object> holidayMap = new HashMap<>();
        holidayMap.put(UtilsConstant.COUNT, "0");
        when(holidayMasterDAO.findHoliday(anyString(), anyString())).thenReturn(holidayMap);

        boolean result = cutoffTimeService.isValidDateAndTime(date, "RTGS", "SBI");
        assertTrue(result);
    }

    @Test
    void testIsValidDateAndTime_NotHoliday() {
        LocalDateTime date = LocalDateTime.of(2025, 10, 14, 10, 0);
        Map<String, Object> holidayMap = new HashMap<>();
        holidayMap.put(UtilsConstant.COUNT, "1");
        when(holidayMasterDAO.findHoliday(anyString(), anyString())).thenReturn(holidayMap);

        boolean result = cutoffTimeService.isValidDateAndTime(date, "RTGS", "SBI");
        assertFalse(result);
    }

    @Test
    void testCutoffValues_NormalDay() {
        LocalDateTime date = LocalDateTime.of(2025, 10, 14, 10, 30);
        Map<String, Integer> map = cutoffTimeService.cutoffValues(date, "RTGS", "SBI");

        assertEquals(10, map.get("intHour"));
        assertEquals(30, map.get("intMinute"));
        assertEquals(9, map.get("startHour"));
        assertEquals(17, map.get("endHour"));
    }

    @Test
    void testCutoffValues_Saturday_RTGS() {
        LocalDateTime date = LocalDateTime.of(2025, 10, 18, 10, 30); // Saturday
        Map<String, Integer> map = cutoffTimeService.cutoffValues(date, "RTGS", "SBI");
        assertEquals(13, map.get("endHour"));
    }

    @Test
    void testIsAuthorizingTime_WithinRange() {
        LocalDateTime date = LocalDateTime.of(2025, 10, 14, 10, 30);
        boolean result = cutoffTimeService.isAuthorizingTime(date, "RTGS", "SBI");
        assertTrue(result);
    }

    @Test
    void testIsAuthorizingTime_OutsideRange() {
        LocalDateTime date = LocalDateTime.of(2025, 10, 14, 18, 30);
        boolean result = cutoffTimeService.isAuthorizingTime(date, "RTGS", "SBI");
        assertFalse(result);
    }

    @Test
    void testGetNextDate() {
        LocalDateTime date = LocalDateTime.of(2025, 10, 14, 10, 0);
        cutoffTimeService.getNextDate(date, 1, "RTGS", "SBI");
        // No exception expected
    }

    @Test
    void testGetNextWorkingDate_Holiday_AndValidDate() {
        LocalDateTime date = LocalDateTime.of(2025, 10, 14, 10, 0);
        Map<String, Object> holidayMap = new HashMap<>();
        holidayMap.put("count", "0");
        when(holidayMasterDAO.findHoliday(anyString(), anyString())).thenReturn(holidayMap);

        when(holidayMasterDAO.findHoliday(anyString(), eq("RTGS"))).thenReturn(holidayMap);

        boolean blFlag = cutoffTimeService.isValidDateAndTime(date, "RTGS", "SBI");
        LocalDateTime result = cutoffTimeService.getNextWorkingDate(date, "RTGS", "SBI");
        assertNotNull(result);
    }

    @Test
    void testIsSameDay_BeforeStartTime() {
        LocalDateTime date = LocalDateTime.of(2025, 10, 14, 8, 30);
        boolean result = cutoffTimeService.isSameDay(date, "RTGS", "SBI");
        assertTrue(result);
    }

    @Test
    void testIsSameDay_AfterStartTime() {
        LocalDateTime date = LocalDateTime.of(2025, 10, 14, 10, 0);
        boolean result = cutoffTimeService.isSameDay(date, "RTGS", "SBI");
        assertFalse(result);
    }

    @Test
    void testDisplayCutoffValues_RTGS() {
        Map<String, Object> map = cutoffTimeService.displayCutoffValues("RTGS", "SBI");
        assertTrue(map.containsKey("RTGS_startHour"));
        assertTrue(map.containsKey("RTGS_endHour"));
        assertTrue(map.containsKey("RTGS_sat_endStamp"));
    }

    @Test
    void testDisplayCutoffValues_NEFT() {
        Map<String, Object> map = cutoffTimeService.displayCutoffValues("NEFT", "SBI");
        assertTrue(map.containsKey("NEFT_startHour"));
    }

    @Test
    void testIsScheduleTrue_True() {
        boolean result = cutoffTimeService.isScheduleTrue("RTGS", "SBI");
        assertTrue(result);
    }

    @Test
    void testIsScheduleTrue_False() {
        when(referenceDataCache.getCutOffTime()).thenReturn(new HashMap<>());
        boolean result = cutoffTimeService.isScheduleTrue("RTGS", "SBI");
        assertFalse(result);
    }

    @Test
    void testGetReferenceMapForInvalidMode() {
        Map<String, String> result = invokePrivateReferenceMap("XYZ");
        assertTrue(result.isEmpty());
    }

    // helper method to test private getReferenceMap
    private Map<String, String> invokePrivateReferenceMap(String mode) {
        try {
            var method = CutoffTimeService.class.getDeclaredMethod("getReferenceMap", String.class);
            method.setAccessible(true);
            return (Map<String, String>) method.invoke(cutoffTimeService, mode);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
