package com.sbi.yb.services.service.impl;

import com.sbi.microservice.framework.exception.BusinessException;
import com.sbi.microservice.framework.model.CorporateProfile;
import com.sbi.microservice.framework.services.CorporateService;
import com.sbi.yb.services.cache.ReferenceDataCache;
import com.sbi.yb.services.constants.MergerConstants;
import com.sbi.yb.services.constants.UtilsConstant;
import com.sbi.yb.services.model.CorpTransaction;
import com.sbi.yb.services.model.CorporateTransactionLeg;
import com.sbi.yb.services.repository.AuthorizeOrRejectSelectionListDAO;
import com.sbi.yb.services.repository.DealerPaymentDAO;
import com.sbi.yb.services.repository.ValidationFilterDAO;
import com.sbi.yb.services.service.ManageTransactionServiceDetails;
import com.sbi.yb.services.utils.CorpTransactionUtil;
import com.sbi.yb.services.utils.ImpsTransactionUtil;
import com.sbi.yb.services.utils.TransactionRequestMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class AuthorizationEchequeServiceTest {

    @Mock
    private CorporateService corporateService;

    @Mock
    private AuthorizeOrRejectSelectionListDAO authorizeOrRejectSelectionListDAO;

    @Mock
    private DealerPaymentDAO dealerPaymentDAOImpl;

    @Mock
    private ValidationFilterDAO validationFilterDAOImpl;

    @Mock
    private CutoffTimeService cutoffTimeService;

    @Mock
    private ReferenceDataCache referenceDataCache;

    @Mock
    private ManageTransactionServiceDetails manageTransactionDetails;

    @Mock
    private CorpTransactionUtil corpTransactionUtil;

    @Mock
    private ImpsTransactionUtil impsTransactionUtil;

    @Mock
    private RequestMapperFactory requestMapperFactory;

    @InjectMocks
    private AuthorizationEchequeService authorizationEchequeService;

    private CorporateTransactionLeg debitLeg;
    private List<CorporateTransactionLeg> transactionDetails;
    private final String userName = "testUser";
    private final String corporateId = "testCorp";
    private final String gstnNo = "testGSTN";

    @BeforeEach
    void setUp() {
        debitLeg = new CorporateTransactionLeg();
        debitLeg.setEchequeNo("CK123456");
        debitLeg.setAuthFlag("YES");
        debitLeg.setCurrentAuthLevel("1");
        debitLeg.setScheduledDate(LocalDateTime.now().plusDays(1));
        debitLeg.setBranchCode("0123");
        debitLeg.setMerchantCode("IMPS");

        transactionDetails = Arrays.asList(debitLeg);
    }

    @Test
    void authorizeEcheques_WithNullTransactionDetails_ShouldReturnNull() {
        // Act
        List<CorporateTransactionLeg> result = authorizationEchequeService.authorizeEcheques(null, userName, corporateId, gstnNo);

        // Assert
        assertNull(result);
    }

    @Test
    void authorizeEcheques_WithValidTransactionDetails_ShouldProcessAllLegs() {
        // Arrange
        MergerConstants.ABSMerger = Arrays.asList("0", "1");
        
        // Act
        List<CorporateTransactionLeg> result = authorizationEchequeService.authorizeEcheques(transactionDetails, userName, corporateId, gstnNo);

        // Assert
        assertNotNull(result);
        assertEquals(1, result.size());
    }

    @Test
    void authorizeEcheques_WithPastScheduledDate_ShouldUpdateToCurrentDate() {
        // Arrange
        CorporateTransactionLeg pastDebitLeg = new CorporateTransactionLeg();
        pastDebitLeg.setEchequeNo("CK123457");
        pastDebitLeg.setAuthFlag("YES");
        pastDebitLeg.setCurrentAuthLevel("1");
        pastDebitLeg.setScheduledDate(LocalDateTime.now().minusDays(1));
        pastDebitLeg.setBranchCode("1123");
        pastDebitLeg.setMerchantCode("IMPS");
        
        List<CorporateTransactionLeg> pastTransactions = Arrays.asList(pastDebitLeg);

        // Act
        List<CorporateTransactionLeg> result = authorizationEchequeService.authorizeEcheques(pastTransactions, userName, corporateId, gstnNo);

        // Assert
        assertNotNull(result);
    }

    @Test
    void debitLegAuthorizationDetails_WithAuthFlagNo_ShouldSetStatus() {
        // Arrange
        debitLeg.setAuthFlag("NO");

        // Act
        CorporateTransactionLeg result = authorizationEchequeService.debitLegAuthorizationDetails(
            debitLeg, LocalDateTime.now(), LocalDateTime.now(), userName, "0", corporateId, gstnNo);

        // Assert
        assertNotNull(result);
        assertEquals("Echeque cannot be authorized", result.getStatus());
    }

    @Test
    void debitLegAuthorizationDetails_WithDealerPaymentMode_ShouldProcessDealer() {
        // Arrange
        debitLeg.setMerchantCode("DEALER");
        debitLeg.setEchequeNo("CM123456");
        when(cutoffTimeService.isValidDateAndTime(any(), eq("DEALER"), eq("0"))).thenReturn(true);

        // Act
        CorporateTransactionLeg result = authorizationEchequeService.debitLegAuthorizationDetails(
            debitLeg, LocalDateTime.now(), LocalDateTime.now(), userName, "0", corporateId, gstnNo);

        // Assert
        assertNotNull(result);
        verify(dealerPaymentDAOImpl).findExceedingConsignOutstanding(anyString());
    }

    @Test
    void debitLegAuthorizationDetails_WithDealerPaymentMode_ShouldThrowExceptionForInvalidTime() {
        // Arrange
        debitLeg.setMerchantCode("DEALER");
        debitLeg.setEchequeNo("CM123456");
        debitLeg.setCurrentAuthLevel("0");
        when(cutoffTimeService.isValidDateAndTime(any(), eq("DEALER"), eq("0"))).thenReturn(false);

        // Act & Assert
        assertThrows(BusinessException.class, () -> 
            authorizationEchequeService.debitLegAuthorizationDetails(
                debitLeg, LocalDateTime.now(), LocalDateTime.now(), userName, "0", corporateId, gstnNo));
    }

    @Test
    void debitLegAuthorizationDetails_WithIMPSPaymentMode_ShouldProcessIMPS() {
        // Arrange
        debitLeg.setMerchantCode("IMPS");
        when(cutoffTimeService.isScheduleTrue(eq("CORP_IMPS"), eq("0"))).thenReturn(true);
        when(cutoffTimeService.isValidDateAndTime(any(), eq("CORP_IMPS"), eq("0"))).thenReturn(true);

        // Act
        CorporateTransactionLeg result = authorizationEchequeService.debitLegAuthorizationDetails(
            debitLeg, LocalDateTime.now(), LocalDateTime.now(), userName, "0", corporateId, gstnNo);

        // Assert
        assertNotNull(result);
    }

    @Test
    void debitLegAuthorizationDetails_WithIMPSPaymentMode_ShouldThrowExceptionForCutoffTime() {
        // Arrange
        debitLeg.setMerchantCode("IMPS");
        debitLeg.setCurrentAuthLevel("0");
        when(cutoffTimeService.isScheduleTrue(eq("CORP_IMPS"), eq("0"))).thenReturn(true);
        when(cutoffTimeService.isValidDateAndTime(any(), eq("CORP_IMPS"), eq("0"))).thenReturn(false);

        // Act & Assert
        assertThrows(BusinessException.class, () -> 
            authorizationEchequeService.debitLegAuthorizationDetails(
                debitLeg, LocalDateTime.now(), LocalDateTime.now(), userName, "0", corporateId, gstnNo));
    }

    @Test
    void validatingOtherTransactionDetails_WithValidSchedule_ShouldUpdateAuthLevel() {
        // Arrange
        debitLeg.setCurrentAuthLevel("0");
        when(cutoffTimeService.isScheduleTrue(anyString(), anyString())).thenReturn(true);
        when(cutoffTimeService.isValidDateAndTime(any(), anyString(), anyString())).thenReturn(false);
        when(cutoffTimeService.getNextWorkingDate(any(), anyString(), anyString()))
            .thenReturn(LocalDateTime.now().plusDays(1));

        // Act
        CorporateTransactionLeg result = authorizationEchequeService.validatingOtherTransactionDetails(
            debitLeg, LocalDateTime.now(), "TEST_MODE", "0");

        // Assert
        assertNotNull(result);
        assertEquals("50", result.getCurrentAuthLevel());
    }

    @Test
    void validatingImpsDetails_WithValidCutoff_ShouldProcessNormally() {
        // Arrange
        when(cutoffTimeService.isScheduleTrue(eq("CORP_IMPS"), eq("0"))).thenReturn(true);
        when(cutoffTimeService.isValidDateAndTime(any(), eq("CORP_IMPS"), eq("0"))).thenReturn(true);

        // Act
        CorporateTransactionLeg result = authorizationEchequeService.validatingImpsDetails(
            debitLeg, LocalDateTime.now(), "IMPS", "0");

        // Assert
        assertNotNull(result);
    }

    @Test
    void validatingDealerDetails_WithValidTime_ShouldProcessNormally() {
        // Arrange
        debitLeg.setCurrentAuthLevel("0");
        when(cutoffTimeService.isValidDateAndTime(any(), eq("DEALER"), eq("0"))).thenReturn(true);

        // Act
        CorporateTransactionLeg result = authorizationEchequeService.validatingDealerDetails(
            debitLeg, LocalDateTime.now(), "DEALER", "0");

        // Assert
        assertNotNull(result);
        verify(dealerPaymentDAOImpl).findExceedingConsignOutstanding(anyString());
        verify(dealerPaymentDAOImpl).findInterestRoutineExecution(anyString());
    }

    @Test
    void setCurrentAuthLevelInTransaction_WithCSTransaction_ShouldScheduleForCutoff() {
        // Arrange
        debitLeg.setEchequeNo("CS123456");
        debitLeg.setCurrentAuthLevel("0");
        LocalDateTime today = LocalDateTime.now();
        LocalDateTime payDate = LocalDateTime.now().plusDays(1);
        
        Map<String, String> transactionLimit = new HashMap<>();
        transactionLimit.put("CS_CUTOFF_START_TIME_0", "09:00");
        when(cutoffTimeService.isValidDateAndTime(any(), eq("CS"), eq("0"))).thenReturn(false);
        when(cutoffTimeService.getNextWorkingDate(any(), eq("CS"), eq("0")))
            .thenReturn(LocalDateTime.now().plusDays(1));
        when(referenceDataCache.getTransactionLimit()).thenReturn(transactionLimit);
        
        Map<String, Object> userMap = new HashMap<>();
        userMap.put("user_type", "1");
        userMap.put("mobile_no", "1234567890");
        when(validationFilterDAOImpl.getUserProfileDetails(eq(userName), eq(corporateId))).thenReturn(userMap);

        // Act
        CorporateTransactionLeg result = authorizationEchequeService.setCurrentAuthLevelInTransaction(
            debitLeg, today, payDate, "0", userName, corporateId, gstnNo);

        // Assert
        assertNotNull(result);
        assertEquals("50", result.getCurrentAuthLevel());
    }

    @Test
    void setCurrentAuthLevelInTransaction_WithCOTAndAadhar_ShouldSetAuthLevelTo85() {
        // Arrange
        debitLeg.setEchequeNo("CO123456");
        debitLeg.setMerchantCode("AADHAR");
        debitLeg.setCurrentAuthLevel("1");
        
        Map<String, Object> userMap = new HashMap<>();
        userMap.put("user_type", "1");
        userMap.put("mobile_no", "1234567890");
        when(validationFilterDAOImpl.getUserProfileDetails(eq(userName), eq(corporateId))).thenReturn(userMap);

        // Act
        CorporateTransactionLeg result = authorizationEchequeService.setCurrentAuthLevelInTransaction(
            debitLeg, LocalDateTime.now(), LocalDateTime.now(), "0", userName, corporateId, gstnNo);

        // Assert
        assertNotNull(result);
        assertEquals("85", result.getCurrentAuthLevel());
    }

    @Test
    void setCurrentAuthLevelInTransaction_WithUserType8_ShouldSetAuthLevelTo99() {
        // Arrange
        Map<String, Object> userMap = new HashMap<>();
        userMap.put("user_type", "8");
        userMap.put("mobile_no", "1234567890");
        when(validationFilterDAOImpl.getUserProfileDetails(eq(userName), eq(corporateId))).thenReturn(userMap);

        // Act
        CorporateTransactionLeg result = authorizationEchequeService.setCurrentAuthLevelInTransaction(
            debitLeg, LocalDateTime.now(), LocalDateTime.now(), "0", userName, corporateId, gstnNo);

        // Assert
        assertNotNull(result);
        assertEquals("99", result.getCurrentAuthLevel());
    }

    @Test
    void postTransaction_WithOnlineMode_ShouldProcessTransaction() {
        // Arrange
        debitLeg.setCurrentAuthLevel("0");
        
        CorporateProfile corporateProfile = new CorporateProfile(
            corporateId, "Test Corp", "Address1", "Address2", 
            "City", "State", "123456", "ACTIVE");
        
        when(corporateService.getCorporateProfile(corporateId)).thenReturn(corporateProfile);
        when(validationFilterDAOImpl.getUserProfileDetails(eq(userName), eq(corporateId)))
            .thenReturn(Collections.singletonMap("mobile_no", "1234567890"));
        
        // Mock the mapper and transaction processing
        TransactionRequestMapper mockMapper = mock(TransactionRequestMapper.class);
        CorpTransaction mockCorpTransaction = new CorpTransaction();
        mockCorpTransaction.setDebit(debitLeg);
        
        when(requestMapperFactory.getRequestMapper(anyString())).thenReturn(mockMapper);
        when(mockMapper.getTransactionObject(anyMap())).thenReturn(mockCorpTransaction);
        when(corpTransactionUtil.postTransaction(any(), eq("ONLINE_MODE"), eq(userName)))
            .thenReturn(mockCorpTransaction);
        when(manageTransactionDetails.setEchequePropeties(any())).thenReturn(debitLeg);

        // Act
        CorporateTransactionLeg result = authorizationEchequeService.postTransaction(
            debitLeg, corporateId, userName, "1234567890", gstnNo);

        // Assert
        assertNotNull(result);
        verify(corpTransactionUtil).postTransaction(any(), eq("ONLINE_MODE"), eq(userName));
    }

    @Test
    void postTransaction_WithCJTransaction_ShouldProcessImps() {
        // Arrange
        debitLeg.setCurrentAuthLevel("0");
        debitLeg.setEchequeNo("CJ123456");
        
        CorporateProfile corporateProfile = new CorporateProfile(
            corporateId, "Test Corp", "Address1", "Address2", 
            "City", "State", "123456", "ACTIVE");
        
        when(corporateService.getCorporateProfile(corporateId)).thenReturn(corporateProfile);
        when(validationFilterDAOImpl.getUserProfileDetails(eq(userName), eq(corporateId)))
            .thenReturn(Collections.singletonMap("mobile_no", "1234567890"));
        
        TransactionRequestMapper mockMapper = mock(TransactionRequestMapper.class);
        CorpTransaction mockCorpTransaction = new CorpTransaction();
        CorporateTransactionLeg updatedDebitLeg = new CorporateTransactionLeg();
        updatedDebitLeg.setEchequeNo("CJ123456");
        updatedDebitLeg.setMobileNo("1234567890");
        mockCorpTransaction.setDebit(updatedDebitLeg);
        
        when(requestMapperFactory.getRequestMapper(anyString())).thenReturn(mockMapper);
        when(mockMapper.getTransactionObject(anyMap())).thenReturn(mockCorpTransaction);
        when(corpTransactionUtil.postTransaction(any(), eq("ONLINE_MODE"), eq(userName)))
            .thenReturn(mockCorpTransaction);
        when(manageTransactionDetails.setEchequePropeties(any())).thenReturn(updatedDebitLeg);

        // Act
        CorporateTransactionLeg result = authorizationEchequeService.postTransaction(
            debitLeg, corporateId, userName, "1234567890", gstnNo);

        // Assert
        assertNotNull(result);
        verify(impsTransactionUtil).postRequestForImpsTransaction(any());
    }

    @Test
    void postTransaction_WithFileMode_ShouldProcessTransaction() {
        // Arrange
        debitLeg.setCurrentAuthLevel("2");
        debitLeg.setEchequeNo("CQ123456");
        
        when(validationFilterDAOImpl.getUserProfileDetails(eq(userName), eq(corporateId)))
            .thenReturn(Collections.singletonMap("mobile_no", "1234567890"));
        
        TransactionRequestMapper mockMapper = mock(TransactionRequestMapper.class);
        CorpTransaction mockCorpTransaction = new CorpTransaction();
        mockCorpTransaction.setDebit(debitLeg);
        
        when(requestMapperFactory.getRequestMapper(anyString())).thenReturn(mockMapper);
        when(mockMapper.getTransactionObject(anyMap())).thenReturn(mockCorpTransaction);
        when(corpTransactionUtil.postTransaction(any(), eq("FILE_MODE"), eq(userName)))
            .thenReturn(mockCorpTransaction);
        when(manageTransactionDetails.setEchequePropeties(any())).thenReturn(debitLeg);

        // Act
        CorporateTransactionLeg result = authorizationEchequeService.postTransaction(
            debitLeg, corporateId, userName, "1234567890", gstnNo);

        // Assert
        assertNotNull(result);
        verify(corpTransactionUtil).postTransaction(any(), eq("FILE_MODE"), eq(userName));
    }

    @Test
    void getEchequeStatus_WithAuthLevel0_ShouldReturnAuthorizedMessage() {
        // Arrange
        debitLeg.setCurrentAuthLevel("0");

        // Act
        String result = authorizationEchequeService.getEchequeStatus(debitLeg);

        // Assert
        assertEquals("Echeque Authorized successfully.", result);
    }

    @Test
    void getEchequeStatus_WithAuthLevel2_ShouldReturnAwaitingMessage() {
        // Arrange
        debitLeg.setCurrentAuthLevel("2");

        // Act
        String result = authorizationEchequeService.getEchequeStatus(debitLeg);

        // Assert
        assertEquals("Echeque Authorized successfully. Awaiting for second level authorization.", result);
    }

    @Test
    void getTransactionName_WithCDTransaction_ShouldReturnCorpDD() {
        // Arrange
        debitLeg.setEchequeNo("CD123456");

        // Act
        String result = authorizationEchequeService.getTransactionName(debitLeg);

        // Assert
        assertEquals("CORP_DD", result);
    }

    @Test
    void getTransactionName_WithCKTransaction_ShouldReturnCorpSpl() {
        // Arrange
        debitLeg.setEchequeNo("CK123456");

        // Act
        String result = authorizationEchequeService.getTransactionName(debitLeg);

        // Assert
        assertEquals("CORP_SPL", result);
    }

    @Test
    void getTransactionName_WithCSTransaction_ShouldReturnCorpSpl() {
        // Arrange
        debitLeg.setEchequeNo("CS123456");

        // Act
        String result = authorizationEchequeService.getTransactionName(debitLeg);

        // Assert
        assertEquals("CORP_SPL", result);
    }

    @Test
    void getTransactionName_WithOtherTransaction_ShouldReturnCorpOther() {
        // Arrange
        debitLeg.setEchequeNo("CQ123456");

        // Act
        String result = authorizationEchequeService.getTransactionName(debitLeg);

        // Assert
        assertEquals("CORP_OTHER", result);
    }

    @Test
    void getTransactionName_WithNullEchequeNo_ShouldReturnNull() {
        // Arrange
        debitLeg.setEchequeNo(null);

        // Act
        String result = authorizationEchequeService.getTransactionName(debitLeg);

        // Assert
        assertNull(result);
    }

    @Test
    void modifyAuthorizationParameter_ShouldUpdateAuthorizationDetails() {
        // Arrange
        String ipAddress = "192.168.1.1";

        // Act
        CorporateTransactionLeg result = authorizationEchequeService.modifyAuthorizationParameter(
            debitLeg, userName, ipAddress);

        // Assert
        assertNotNull(result);
        // Add more specific assertions based on your business logic
    }

    // Helper methods for the unimplemented private methods
    @Test
    void findMerchantName_ShouldReturnMerchantCode() {
        // This would test the private method indirectly through postTransaction
        // Implementation depends on the actual logic
    }

    @Test
    void findMapper_ShouldReturnMapperName() {
        // This would test the private method indirectly through po
