package com.sbi.yb.services.service.impl;


import com.sbi.microservice.framework.exception.BusinessException;
import com.sbi.microservice.framework.model.CorporateProfile;
import com.sbi.microservice.framework.repository.CorporateDAO;
import com.sbi.microservice.framework.services.CorporateService;
import com.sbi.microservice.framework.utils.StringUtils;
import com.sbi.yb.services.cache.ReferenceDataCache;
import com.sbi.yb.services.constants.MergerConstants;
import com.sbi.yb.services.constants.UtilsConstant;
import com.sbi.yb.services.model.CorpTransaction;
import com.sbi.yb.services.model.CorporateTransactionLeg;
import com.sbi.yb.services.repository.AuthorizeOrRejectSelectionListDAO;
import com.sbi.yb.services.repository.DealerPaymentDAO;
import com.sbi.yb.services.repository.ValidationFilterDAO;
import com.sbi.yb.services.service.ManageTransactionServiceDetails;
import com.sbi.yb.services.utils.CorpTransactionUtil;
import com.sbi.yb.services.utils.ImpsTransactionUtil;
import com.sbi.yb.services.utils.TransactionRequestMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * @author V1017583
 * 1.	Loop through echequelist to authorize
 * 2.	Check the authflag of echeque to authorize
 * 3.	if the authflag is set to "no" then the echeque will not be processed
 * 4.	else call modifyAuthorizationParameter to set new value for current_auth_level,auth1_name/auth2_name and other details for the echeque
 * 5.	If the modified current_auth_level is set to 0, then set txnType as "ONLINE_MODE" else set as "OFFLINE_MODE"
 * 6.	if ONLINE_MODE
 * i.		Call findMerchantName to find the merchant for the echeque
 * ii.		set merchantcode for the echeque
 * iii.	Call findMapper to find the request mapper to be used, it will either corpDDTransactionRequestMapper or corpTransactionRequestMapper
 * iv.		Call getTransactionObject which will set credit legs and other details required for posting.
 * 7.	Call postTransaction to post(ONLINE_MODE) and to update echeque details
 * 8.	Call transactionManageBP.setEchequePropeties to set status and details of the echeque.
 */

@Component
public class AuthorizationEchequeService {
  /**
   * LOGGER.
   **/
  private final Logger logger = LoggerFactory.getLogger(AuthorizationEchequeService.class);


  private final CorporateService corporateService;

  private final AuthorizeOrRejectSelectionListDAO authorizeOrRejectSelectionListDAO;

  private final DealerPaymentDAO dealerPaymentDAOImpl;

  private final ValidationFilterDAO validationFilterDAOImpl;

  private final CutoffTimeService cutoffTimeService;

  private final ReferenceDataCache referenceDataCache;

  private final ManageTransactionServiceDetails manageTransactionDetails;

  private final ImpsTransactionUtil impsTransactionUtil;

  private final RequestMapperFactory requestMapperFactory;

  /**
   * corpTransactionUtil
   */
  private CorpTransactionUtil corpTransactionUtil;

  @Autowired
  public AuthorizationEchequeService( AuthorizeOrRejectSelectionListDAO authorizeOrRejectSelectionListDAO,
                                     DealerPaymentDAO dealerPaymentDAOImpl, CutoffTimeService cutoffTimeService, ReferenceDataCache referenceDataCache,
                                     ValidationFilterDAO validationFilterDAOImpl, ManageTransactionServiceDetails manageTransactionDetails, CorpTransactionUtil corpTransactionUtil, ImpsTransactionUtil impsTransactionUtil,
                                     final RequestMapperFactory requestMapperFactory, final CorporateService corporateService) {

    this.authorizeOrRejectSelectionListDAO = authorizeOrRejectSelectionListDAO;
    this.dealerPaymentDAOImpl = dealerPaymentDAOImpl;
    this.cutoffTimeService = cutoffTimeService;
    this.referenceDataCache = referenceDataCache;
    this.validationFilterDAOImpl = validationFilterDAOImpl;
    this.manageTransactionDetails = manageTransactionDetails;
    this.corpTransactionUtil = corpTransactionUtil;
    this.impsTransactionUtil = impsTransactionUtil;
    this.requestMapperFactory=requestMapperFactory;
    this.corporateService = corporateService;
  }

  /**
   * @param transactionDetails
   * @param userName
   * @param corporateId
   * @param gstnNo
   * @return
   */
  public List<CorporateTransactionLeg> authorizeEcheques(List<CorporateTransactionLeg> transactionDetails, String userName, String corporateId, String gstnNo) {

    logger.info("Authorization authorizeEcheques(AuthorizationBP) ****  Begins");
    List<CorporateTransactionLeg> echqList = null;
    if (transactionDetails != null) {

      //Added For Aadhaar Account
      logger.info("gstnNo ::::{}", gstnNo);

      echqList = transactionDetails.stream().map(debitLeg -> {

        LocalDateTime payDate = debitLeg.getScheduledDate();
        LocalDateTime today = LocalDateTime.now();
        logger.info("debitLeg.getScheduledDate():{},today::{},before::{}", debitLeg.getScheduledDate(), today, payDate.isBefore(today));
        payDate = payDate.isBefore(today) ? today : payDate;


        String branchCode = debitLeg.getBranchCode();
        String debitBankcCode = branchCode.substring(0, 1);

        if (debitBankcCode != null && MergerConstants.ABSMerger != null && MergerConstants.ABSMerger.contains(debitBankcCode))
          debitBankcCode = "0";


        return debitLegAuthorizationDetails(debitLeg, payDate, today, userName, debitBankcCode, corporateId, gstnNo);

      }).toList();


    }
    return echqList;
  }

  /**
   *
   * @param debitLeg
   * @param payDate
   * @param today
   * @param userName
   * @param debitBankcCode
   * @param coporateId
   * @param gstnNo
   * @return
   */
  public CorporateTransactionLeg debitLegAuthorizationDetails(CorporateTransactionLeg debitLeg, LocalDateTime payDate, LocalDateTime today, String userName, String debitBankcCode, String coporateId, String gstnNo) {
    String iPAddress = null;
    if (debitLeg.getAuthFlag().equalsIgnoreCase(UtilsConstant.YES)) {
      modifyAuthorizationParameter(debitLeg, userName, iPAddress);
      String paymentMode = debitLeg.getMerchantCode();

      if (debitLeg.getEchequeNo() != null && debitLeg.getEchequeNo().substring(0, 2).equalsIgnoreCase("CM")) {
        paymentMode = "DEALER";
      }
      logger.info("paymentMode :{},payDate::{}", paymentMode, payDate);

      if (paymentMode != null) {
        switch (paymentMode) {
          case "DEALER" -> validatingDealerDetails(debitLeg, payDate, paymentMode, debitBankcCode);


          case "IMPS" -> validatingImpsDetails(debitLeg, payDate, paymentMode, debitBankcCode);

          default -> validatingOtherTransactionDetails(debitLeg, payDate, paymentMode, debitBankcCode);

        }
      }
      debitLeg = setCurrentAuthLevelInTransaction(debitLeg, today, payDate, debitBankcCode, userName, coporateId, gstnNo);

    } else {
      logger.info("Authorization authorizeEcheques(AuthorizationBP) **** Validation Failed: Echeque cannot be authorized for echequeNo : {}", debitLeg.getEchequeNo());

      if (debitLeg.getStatus() == null)
        debitLeg.setStatus("Echeque cannot be authorized");
    }

    return debitLeg;
  }

  /**
   *
   * @param debitLeg
   * @param payDate
   * @param paymentMode
   * @param debitBankcCode
   * @return
   */
  public CorporateTransactionLeg validatingOtherTransactionDetails(CorporateTransactionLeg debitLeg, LocalDateTime payDate, String paymentMode, String debitBankcCode) {
    boolean isScheduleTrue = false;
    isScheduleTrue = cutoffTimeService.isScheduleTrue(paymentMode, debitBankcCode);
    if (isScheduleTrue) {
      logger.info("inside Scheduling");
      if (paymentMode != null && debitLeg.getCurrentAuthLevel().equals("0") && !cutoffTimeService.isValidDateAndTime(payDate, paymentMode, debitBankcCode)) {
        LocalDateTime nextDate = cutoffTimeService.getNextWorkingDate(payDate, paymentMode, debitBankcCode);
        DateTimeFormatter scheduleDate = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");
        logger.info("scheduleDate :{}", scheduleDate);
        debitLeg.setCurrentAuthLevel("50");
        debitLeg.setScheduledDate(LocalDateTime.parse(nextDate.format(scheduleDate)));
        debitLeg.setScheduled("0");
      }

    }
    return debitLeg;
  }

  /**
   *
   * @param debitLeg
   * @param payDate
   * @param paymentMode
   * @param debitBankcCode
   * @return
   */
  public CorporateTransactionLeg validatingImpsDetails(CorporateTransactionLeg debitLeg, LocalDateTime payDate, String paymentMode, String debitBankcCode) {
    boolean isScheduleTrue = false;
    isScheduleTrue = cutoffTimeService.isScheduleTrue("CORP_" + paymentMode, debitBankcCode);
    if (isScheduleTrue) {
      logger.info("inside Scheduling");
      if (debitLeg.getCurrentAuthLevel().equals("0") && cutoffTimeService.isValidDateAndTime(payDate, "CORP_" + paymentMode, debitBankcCode)) {
        throw new BusinessException("IMPS services are currently not available between 10:45 PM and 11:15 PM", "");
      }
    }
    return debitLeg;
  }

  /**
   *
   * @param debitLeg
   * @param payDate
   * @param paymentMode
   * @param debitBankcCode
   * @return
   */
  public CorporateTransactionLeg validatingDealerDetails(CorporateTransactionLeg debitLeg, LocalDateTime payDate, String paymentMode, String debitBankcCode) {
    dealerPaymentDAOImpl.findExceedingConsignOutstanding(debitLeg.getEchequeNo());
    if (debitLeg.getCurrentAuthLevel().equals("0")) {
      if (!cutoffTimeService.isValidDateAndTime(payDate, paymentMode, debitBankcCode))
        throw new BusinessException("ealer Finance payment can be made only from 4AM to 11PM", "");
      dealerPaymentDAOImpl.findInterestRoutineExecution(debitLeg.getEchequeNo());
    }
    return debitLeg;
  }

  /**
   *
   * @param debitLeg
   * @param today
   * @param payDate
   * @param debitBankcCode
   * @param userName
   * @param corporateId
   * @param gstnNO
   * @return
   */
  public CorporateTransactionLeg setCurrentAuthLevelInTransaction(CorporateTransactionLeg debitLeg, LocalDateTime today, LocalDateTime payDate, String debitBankcCode, String userName, String corporateId, String gstnNO) {
    String csTxnNo = debitLeg.getEchequeNo();
    if (csTxnNo != null && csTxnNo.substring(0, 2).equalsIgnoreCase("CS")) {
      if (debitLeg.getCurrentAuthLevel().equals("0") && !cutoffTimeService.isValidDateAndTime(today, "CS", debitBankcCode)) {
        logger.info("CS transaction going to scheduled mode....");
        LocalDateTime nextDate = cutoffTimeService.getNextWorkingDate(payDate, "CS", debitBankcCode);
        Map<String, String> data = referenceDataCache.getTransactionLimit();
        String startTime = data.get(csTxnNo.substring(0, 2) + "_CUTOFF_START_TIME_" + debitBankcCode);
        String[] startTimeArray = startTime.split(":");
        LocalDateTime newDateTime = nextDate.withHour(Integer.parseInt(startTimeArray[0])).withMinute(Integer.parseInt(startTimeArray[1]));
        DateTimeFormatter scheduleDate = DateTimeFormatter.ofPattern("dd/MM/yyyy:HH:mm");
        logger.info("CS transaction final scheduleDate :{}", scheduleDate);
        debitLeg.setCurrentAuthLevel("50");
        debitLeg.setScheduledDate(LocalDateTime.parse(newDateTime.format(scheduleDate)));
        debitLeg.setScheduled("0");
      }
    } else if (debitLeg.getEchequeNo() != null && debitLeg.getEchequeNo().substring(0, 2).equalsIgnoreCase("CO") &&
            debitLeg.getMerchantCode() != null && debitLeg.getMerchantCode().equalsIgnoreCase("AADHAR") && !debitLeg.getCurrentAuthLevel().equals("2")) {
      debitLeg.setCurrentAuthLevel("85");
    }

    Map<String, Object> userMap = validationFilterDAOImpl.getUserProfileDetails(userName, corporateId);
    String userType = String.valueOf(userMap.get("user_type"));
    String mobileNo = String.valueOf(userMap.get("mobile_no"));

    // For CPSMS Aadhaar Request
    if (userType != null && userType.equalsIgnoreCase("8") && !debitLeg.getCurrentAuthLevel().equals("2"))
      debitLeg.setCurrentAuthLevel("99");


    logger.info("current auth level for echeque {}, is ::{} ", debitLeg.getEchequeNo(), debitLeg.getCurrentAuthLevel());

    debitLeg = postTransaction(debitLeg, corporateId, userName, mobileNo, gstnNO);

    logger.info("Updated CorporateTransactionLeg{}",debitLeg);
    return debitLeg;
  }

  /**
   *
   * @param debitLeg
   * @param corporateId
   * @param userName
   * @param mobileNo
   * @param gstnNo
   * @return
   */
  public CorporateTransactionLeg postTransaction(CorporateTransactionLeg debitLeg, String corporateId, String userName, String mobileNo, String gstnNo) {
    String merchantCode = "";
    String mapperName = "";
    String transactionName = "";
    String status = "";

    CorpTransaction corpTransaction = new CorpTransaction();
    Map<String, Object> requestMap = new HashMap<>();
    if (debitLeg.getCurrentAuthLevel().equals("0")) {
      String txnType = "ONLINE_MODE";
      merchantCode = Optional.ofNullable(findMerchantName(debitLeg)).orElseThrow();
      logger.info("Authorization authorizeEcheques(AuthorizationBP) ****  Merchant COde for echequeNo {}, is {}", debitLeg.getEchequeNo(), merchantCode);
      debitLeg.setMerchantCode(merchantCode);
      corpTransaction.setDebit(debitLeg);
      requestMap.put("corpTransaction", corpTransaction);
      requestMap.put("corpId", corporateId);
      mapperName = Optional.ofNullable(findMapper(debitLeg)).orElseThrow();
      logger.info("Authorization authorizeEcheques(AuthorizationBP) ****  Mapper Name for echequeNo{},is{} ", debitLeg.getEchequeNo(), mapperName);
      TransactionRequestMapper corpTransactionRequestMapper=null;
      corpTransactionRequestMapper = requestMapperFactory.getRequestMapper(mapperName);


      corpTransaction = Optional.ofNullable((CorpTransaction) corpTransactionRequestMapper.getTransactionObject(requestMap)).orElseThrow();

      //call through service
      CorporateProfile corpProfile = corporateService.getCorporateProfile(corporateId);

      String corporateName = corpProfile.corporateName();
      String corporateAddress1 = (corpProfile.corporateAddress1() == null ? "" : corpProfile.corporateAddress1());
      String corporateAddress2 = (corpProfile.corporateAddress2() == null ? "" : corpProfile.corporateAddress2());

      String corporateAddress = corporateAddress1 + corporateAddress2;
      String corporateCity = corpProfile.corporateCity();
      String corporateState = corpProfile.corporateState();
      String corporateZip = corpProfile.corporatePincode();


      if (corpTransaction.getName() == null) // for CK & CS transaction name will be set in request mapper itself
      {
        transactionName = Optional.ofNullable(getTransactionName(debitLeg)).orElseThrow();
        logger.info("Authorization authorizeEcheques ****  Transaction Name for echequeNo{} is {}", debitLeg.getEchequeNo(), transactionName);
        corpTransaction.setName(transactionName);
      }
      corpTransaction.setUserName(userName);
      corpTransaction.setCorporateId(corporateId);
      corpTransaction.setCorporateName(corporateName);
      corpTransaction.setCorpAddress(corporateAddress);
      corpTransaction.setCorpCity(corporateCity);
      corpTransaction.setCorpState(corporateState);
      corpTransaction.setCorpZip(corporateZip);
      corpTransaction.setGstnNo(gstnNo);//GSTN_CHG
      logger.info("Authorization authorizeEcheques(AuthorizationBP) **** Set Debit Leg for echequeNo {},( for ONLINE_MODE or when posting is required) ", debitLeg.getEchequeNo());
      logger.info("Authorization authorizeEcheques(AuthorizationBP) ****  Calling Post Transaction method for echequeNo  {}", debitLeg.getEchequeNo());
      corpTransaction = (CorpTransaction) corpTransactionUtil.postTransaction(corpTransaction, txnType, userName);
      logger.info("Authorization authorizeEcheques(AuthorizationBP) ****  Post Transaction method for echequeNo {},returns{} ", debitLeg.getEchequeNo(), corpTransaction);

      debitLeg = ((CorporateTransactionLeg) corpTransaction.getDebit());

      if (debitLeg.getEchequeNo() != null && "CJ".equalsIgnoreCase(debitLeg.getEchequeNo().substring(0, 2))) {
        debitLeg.setMobileNo(mobileNo);
        impsTransactionUtil.postRequestForImpsTransaction(debitLeg);
      }

    } else {
      // for FILE_MODE or current_auth_level=2
      logger.info("Authorization authorizeEcheques(AuthorizationBP) **** Set Debit Leg for echequeNo {} (for FILE_MODE or when posting is not required) ", debitLeg.getEchequeNo());
      corpTransaction.setDebit(debitLeg);
      corpTransaction.setGstnNo(gstnNo);//GSTN_CHG
      String txntype = debitLeg.getEchequeNo().substring(0, 2);
      logger.info("TRANSACTION TYPE-->{}", txntype);

      //CHANGES MADE FOR VAN PAYMENTS BGL REMOVAL STARTS
      if (txntype.equalsIgnoreCase("CQ")) {
        requestMap.put("corpTransaction", corpTransaction);
        requestMap.put("corpId", corporateId);
        mapperName = findMapper(debitLeg);
        logger.info("Authorization authorizeEcheques(AuthorizationBP) ****  Mapper Name for echequeNo {} is {} ", debitLeg.getEchequeNo(), mapperName);
         TransactionRequestMapper corpTransactionRequestMapper = null;
        corpTransactionRequestMapper = requestMapperFactory.getRequestMapper(mapperName);

        corpTransaction = (CorpTransaction) corpTransactionRequestMapper.getTransactionObject(requestMap);
      }
      corpTransaction = (CorpTransaction) corpTransactionUtil.postTransaction(corpTransaction, "FILE_MODE", userName);


    }

    debitLeg = (CorporateTransactionLeg) corpTransaction.getDebit();
    /* assign the status code(TransactionLeg) into debitStatusCode(CorpTransactionLeg)
     *because setEchequePropeties() method dealing with debitStatus of CorpttransactioLeg
     */
    debitLeg.setDebitStatus(debitLeg.getStatusCode());
    debitLeg = manageTransactionDetails.setEchequePropeties(debitLeg);
    status = getEchequeStatus(debitLeg);
    debitLeg.setReason(status);

    return debitLeg;
  }

  /**
   *
   * @param debitLeg
   * @return
   */
  public String getEchequeStatus(CorporateTransactionLeg debitLeg) {
    String status = "";
    String currentAuthlevel = debitLeg.getCurrentAuthLevel();
    if (currentAuthlevel.equalsIgnoreCase("0") || currentAuthlevel.equalsIgnoreCase("50") || currentAuthlevel.equalsIgnoreCase("99") || currentAuthlevel.equalsIgnoreCase("85")) {
      status = "Echeque Authorized successfully.";
    } else if (currentAuthlevel.equalsIgnoreCase("2")) {
      status = "Echeque Authorized successfully. Awaiting for second level authorization.";

    }
    logger.info(" status of echeque :{} ", status);
    return status;
  }

  /**
   *
   * @param debitLeg
   * @return
   */
  public String getTransactionName(CorporateTransactionLeg debitLeg) {
    String txnName = "";
    String echequeNo = debitLeg.getEchequeNo();

    if (echequeNo != null) {
      txnName = switch (txnName) {
        case "CD" -> "CORP_DD";
        case "CK", "CS" -> "CORP_SPL";
        default -> "CORP_OTHER";
      };
    } else {
      txnName = null;
    }
    logger.info(" Transaction Name for echeque : {}", txnName);
    return txnName;
  }

  /**
   *
   * @param corpTransactionLeg
   * @param userName
   * @param iPAddress
   * @return
   */
  public CorporateTransactionLeg modifyAuthorizationParameter(CorporateTransactionLeg corpTransactionLeg, String userName, String iPAddress) {
    int currentAuthlevelint = Integer.parseInt(corpTransactionLeg.getCurrentAuthLevel());
    String userAuthType = "";
    /*--- Auth Type should be checked for Single Authorization and First Level Authorization and Not for Second Level Authorization ---*/
    if (currentAuthlevelint != 2) {
      userAuthType = String.valueOf(authorizeOrRejectSelectionListDAO.findUserAuthType(corpTransactionLeg.getAccountNo(), corpTransactionLeg.getBranchCode(), corpTransactionLeg.getAmount(), userName));

      corpTransactionLeg.setAuthType(userAuthType);
    }

    if (corpTransactionLeg.getAuthType().equals("0"))//single
    {

      firstLevelAuthorization(corpTransactionLeg, userName, iPAddress);


    } else // two level authorization
    {
      secondLevelAuthorization(corpTransactionLeg, userName, iPAddress);

    }

    /*Added  for LSC starts here*/
    if (corpTransactionLeg.getSupplierId() != null && corpTransactionLeg.getSupplierId().equalsIgnoreCase("LSC_PAYMENTS")) {
      corpTransactionLeg.setCurrentAuthLevel("50");
      logger.info("current auth level changed to 50 for LSC transactions::");
    }
    /*Added for LSC ends here*/

    logger.info("Authorization authorizeEcheques for echequeNo {}, ::: Authorisation level : {},Auth type :{},current auth level :{},auth 1 name : {},auth 2 name :{} ", corpTransactionLeg.getEchequeNo(), corpTransactionLeg.getAuthorisationLevel(),
            corpTransactionLeg.getAuthType(), corpTransactionLeg.getCurrentAuthLevel(), corpTransactionLeg.getAuth1Name(), corpTransactionLeg.getAuth2Name());


    return corpTransactionLeg;

  }

  /**
   *
   * @param corpTransactionLeg
   * @param userName
   * @param iPAddress
   */
  public void firstLevelAuthorization(CorporateTransactionLeg corpTransactionLeg, String userName, String iPAddress) {

    String currentAuthLevel = corpTransactionLeg.getCurrentAuthLevel();
    logger.info("Single ::::  Current Auth Level : {}", currentAuthLevel);
    corpTransactionLeg.setAuthorisationLevel("single");
    if (currentAuthLevel.equalsIgnoreCase("1")) {
      corpTransactionLeg.setAuth1Name(userName);
      corpTransactionLeg.setAuth1IP(iPAddress);
      corpTransactionLeg.setAuthType("0");
    } else {
      corpTransactionLeg.setAuthType("1");
    }


    // process immediately with current date, if schedule status is
    // no(1)
    if (corpTransactionLeg.getScheduled().equals("1")) {
      corpTransactionLeg.setScheduledDate(StringUtils.currentTimeStamp().toLocalDateTime());

    }

    logger.info("Single :::  Filename : {}", corpTransactionLeg.getFileName());
    if (corpTransactionLeg.getFileName() == null) {
      // Alteration for Online authorization.
      if (corpTransactionLeg.getScheduled().equals("0") && corpTransactionLeg.getProcessed().equals("1")) {
        corpTransactionLeg.setCurrentAuthLevel("50");
      } else {
        corpTransactionLeg.setCurrentAuthLevel("0");
      }
    } else {
      // Alteration for file mode(bulktxn) authorization.
      corpTransactionLeg.setScheduled("0");
      corpTransactionLeg.setCurrentAuthLevel("50");
      corpTransactionLeg.setProcessed("1");
    }

    firstLevelAuthorizationForImps(corpTransactionLeg);

  }

  /**
   *
   * @param corpTransactionLeg
   * @param userName
   * @param iPAddress
   */
  public void secondLevelAuthorization(CorporateTransactionLeg corpTransactionLeg, String userName, String iPAddress) {
    String currentAuthLevel = corpTransactionLeg.getCurrentAuthLevel();
    corpTransactionLeg.setAuthorisationLevel("joint");
    logger.info("Two level ::::  Current Auth Level : {}", currentAuthLevel);
    if (currentAuthLevel.equalsIgnoreCase("1")) // first level authorization
    {
      corpTransactionLeg.setAuth1Name(userName);
      corpTransactionLeg.setCurrentAuthLevel("2");
      corpTransactionLeg.setAuth1IP(iPAddress);
    } else {
      logger.info("Two level :::  Filename :{} ", corpTransactionLeg.getFileName());
      if (corpTransactionLeg.getFileName() == null) // online mode (view inbox)
      {
        corpTransactionLeg.setAuth2Name(userName);
        corpTransactionLeg.setAuth2IP(iPAddress);
        if (corpTransactionLeg.getScheduled().equals("0") && corpTransactionLeg.getProcessed().equals("1")) {
          corpTransactionLeg.setCurrentAuthLevel("50");
        } else {
          corpTransactionLeg.setCurrentAuthLevel("0");
        }

      } else // for file_mode(bulk inbox)
      {

        corpTransactionLeg.setAuth2Name(userName);
        corpTransactionLeg.setScheduled("0");
        corpTransactionLeg.setCurrentAuthLevel("50");
        corpTransactionLeg.setProcessed("1");
        corpTransactionLeg.setAuth2IP(iPAddress);

      }
      secondLevelAuthorizationForImps(corpTransactionLeg);

    }
  }

  /**
   * @param corpTransactionLeg
   */
  public void secondLevelAuthorizationForImps(CorporateTransactionLeg corpTransactionLeg) {
    if (corpTransactionLeg.getReferenceNo().substring(0, 2).equalsIgnoreCase("CJ")) {//Added for IMPS
      if (isImpsSingleCreditOnlineTxn(corpTransactionLeg) && !"0".equals(corpTransactionLeg.getScheduled())) {
        corpTransactionLeg.setCurrentAuthLevel("0");
      } else {
        corpTransactionLeg.setCurrentAuthLevel("50");
        corpTransactionLeg.setScheduled("0"); //Added for form mode multiple credits imps transaction
        corpTransactionLeg.setProcessed("1");
        corpTransactionLeg.setAuth2Channel("CORPINB");//added for IMPS mobility
      }
      logger.info("current auth level changed to 50 for CJ transactions::");
    }
  }


  /**
   * @param corpTransactionLeg
   */
  public void firstLevelAuthorizationForImps(CorporateTransactionLeg corpTransactionLeg) {
    if (corpTransactionLeg.getReferenceNo().substring(0, 2).equalsIgnoreCase("CJ")) {//Added for IMPS
      if (isImpsSingleCreditOnlineTxn(corpTransactionLeg) && !"0".equals(corpTransactionLeg.getScheduled())) {
        corpTransactionLeg.setCurrentAuthLevel("0");
      } else {
        corpTransactionLeg.setCurrentAuthLevel("50");
        corpTransactionLeg.setAuth1Channel("CORPINB");//added IMPS mobility
      }
      logger.info("current auth level changed to 50 for CJ transactions::");

    }

  }

  /**
   * @param debitLeg
   * @return
   */
  boolean isImpsSingleCreditOnlineTxn(CorporateTransactionLeg debitLeg) {
    boolean returnVal = false;
    Map<String, Object> requestMap = new HashMap<>();
    CorpTransaction corpTransaction = new CorpTransaction();
    String merchantCode = findMerchantName(debitLeg);
    logger.info("Merchant COde for echequeNo {}", merchantCode);
    debitLeg.setMerchantCode(merchantCode);
    corpTransaction.setDebit(debitLeg);
    requestMap.put("corpTransaction", corpTransaction);
    requestMap.put("corpId", debitLeg.getCorporateId());
    String mapperName = Optional.ofNullable(findMapper(debitLeg)).orElseThrow();
    TransactionRequestMapper corpTransactionRequestMapper = requestMapperFactory.getRequestMapper(mapperName);
    corpTransaction = (CorpTransaction) corpTransactionRequestMapper.getTransactionObject(requestMap);
    if (corpTransaction.getCredit() != null && corpTransaction.getCredit().length == 1 && (debitLeg.getFileName() == null || "".equals(debitLeg.getFileName().trim()))) {
      returnVal = true;
    }
    return returnVal;

  }

  /**
   * @param debitLeg
   * @return
   */
  public String findMerchantName(CorporateTransactionLeg debitLeg) {
    logger.info("getMerchantName :{} ", debitLeg.getMerchantCode());
    String merchantCode = null;
    String echequeNo = debitLeg.getEchequeNo();
    String supplierId = debitLeg.getSupplierId();


    echequeNo = echequeNo.substring(0, 2);

    switch (echequeNo) {
      case "CH", "CK", "CR", "CN", "CO", "CJ", "CZ", "CQ" -> merchantCode = debitLeg.getMerchantCode();
      case "CB" -> {
        if (debitLeg.getMerchantCode() == null) {
          merchantCode = "BILL";
        } else merchantCode = debitLeg.getMerchantCode();
      }
      case "CS" -> {
        if ((supplierId.equals("300")) || (supplierId.equals("301")) || (supplierId.equals("302")) || (supplierId.equals("303")) || (supplierId.equals("304"))) {
          merchantCode = "BPCL";
        }

      }
      default -> merchantCode = "CORPORATE";
    }
    return merchantCode;

  }

  /**
   * @param debitLeg
   * @return
   */
  public String findMapper(CorporateTransactionLeg debitLeg) {
    String mapperName = null;
    String echequeNo = debitLeg.getEchequeNo().substring(0, 2);

    switch (echequeNo) {
      case "CK" -> mapperName = "CORP_SPL";
      case "CD" -> mapperName = "CORP_DD";
      case "CQ" -> mapperName = "CORP_VAN";
      default -> mapperName = "CORP_OTHER";
    }
    return mapperName;

  }


}
