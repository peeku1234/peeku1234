package com.sbi.microservice.framework.services;

import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;

import com.sbi.microservice.framework.cache.CacheManager;
import com.sbi.microservice.framework.constant.FrameworkConstants;
import com.sbi.microservice.framework.exception.AccessException;
import com.sbi.microservice.framework.model.Access;
import com.sbi.microservice.framework.model.Authentication;
import com.sbi.microservice.framework.model.Channel;
import com.sbi.microservice.framework.model.CorporateProfile;
import com.sbi.microservice.framework.model.Service;
import com.sbi.microservice.framework.model.UserProfile;
import com.sbi.microservice.framework.repository.ServiceDAO;
import com.sbi.microservice.framework.services.access.AuthenticationProvider;
import com.sbi.microservice.framework.services.access.AuthenticationProviderFactory;
import com.sbi.microservice.framework.utils.FrameworkUtils;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

@org.springframework.stereotype.Service
public class AccessVerifier {

	
	private final AuthenticationProviderFactory authenticationProviderFactory;
	private final ServiceDAO serviceDAO;
	private final CacheManager cacheManager;
	private final FrameworkUtils frameworkUtils;
	
	public AccessVerifier(AuthenticationProviderFactory authenticationProviderFactory,ServiceDAO serviceDAO,CacheManager cacheManager,FrameworkUtils frameworkUtils) {
		this.authenticationProviderFactory=authenticationProviderFactory;
		this.serviceDAO=serviceDAO;
		this.cacheManager=cacheManager;
		this.frameworkUtils=frameworkUtils;
	}

	public Optional<Access> checkServiceAccess(HttpServletRequest request,HttpServletResponse response) throws AccessException{

		String channelId = request.getHeader(FrameworkConstants.CHANNELID);
		String token = request.getHeader(FrameworkConstants.USER_TOKEN);// user token
		String requestURI = request.getRequestURI();
		Optional<String> OptionalServiceName = Optional.of(frameworkUtils.extractServiceName(requestURI));

		String accessStatus = FrameworkConstants.ACCESS_DENIED;
		String accessDescription = FrameworkConstants.STRING_BLANK;
		String entityType = channelId;
		String entityValue = frameworkUtils.getEntityValue(entityType);
		
		String method = request.getMethod().toUpperCase();
		
		if (OptionalServiceName.isPresent()) {
			String serviceName=OptionalServiceName.get();
			boolean isSecuredService=isSecuredService(serviceName);
			String serviceType = (isSecuredService ? FrameworkConstants.SERVICE_TYPE_SECURED : FrameworkConstants.SERVICE_TYPE_OPEN);
			
				
			
			if ("DELETE".equalsIgnoreCase(method) || "OPTIONS".equalsIgnoreCase(method) || "DEBUG".equalsIgnoreCase(method)) {
	        	accessDescription = FrameworkConstants.ACCESS_METHOD_NOT_ALLOWED;
	            return Optional.ofNullable(new Access(serviceName, serviceType, accessStatus, accessDescription, entityType, entityValue));
	        }
			/**
			 * Check if access to the requested service requires verification
			 */
			if (isSecuredService) {
				/**
				 * Check if the channel has access to the requested service
				 */
				if (isChannelAuthorized(serviceName, channelId)) {
					try {
						AuthenticationProvider authProvider = authenticationProviderFactory.getProvider(channelId);
						//Authentication authentication = authProvider.authenticate(request);

						UserProfile userProfile= new UserProfile("-945861992","YBM2Upload",21,"250257",Integer.valueOf(0),"00437");
						CorporateProfile corporateProfile= new CorporateProfile("250257","CNIB2YB 2 Test Corporate");
						Authentication authentication = new Authentication(FrameworkConstants.REQUESTOR_WEB, null, userProfile, corporateProfile, true);
						if (authentication.authenticated()) {
							/**
							 * Check if the user has access to the requested service
							 */
							if (!isUserAuthorized(authentication.userProfile().userRole())) {
								accessDescription = FrameworkConstants.ACCESS_USER_NOT_AUTHORIZED;
							}
							accessStatus = FrameworkConstants.ACCESS_GRANTED;
						} else {
							accessDescription = FrameworkConstants.ACCESS_USER_NOT_AUTHENTICATED;
						}

					} catch (IllegalArgumentException e) {
						accessDescription = FrameworkConstants.ACCESS_UNRECOGNIZED_CHANNEL;
					}
				} else {
					/**
					 * Access to the requested service is denied to the channel
					 */
					accessDescription = FrameworkConstants.ACCESS_CHANNEL_NOT_AUTHORIZED;
				}
			} else {
				/**
				 * Requested service does not require any verification, access to be allowed
				 */
				accessStatus = FrameworkConstants.ACCESS_GRANTED;
			}

			return Optional.ofNullable(new Access(serviceName, serviceType, accessStatus, accessDescription, entityType, entityValue));
		}else {
			//TODO - Throw exception
			return null;
		}
	}

	private boolean isUserAuthorized(int userRole) {
		// TODO - User Rationalization to be enabled
		return false;
	}

	private boolean isSecuredService(String serviceName) {
		Optional<Service> optionalService=Optional.ofNullable(cacheManager.getService(serviceName));
		if(optionalService.isPresent()) {
			return (optionalService.get().serviceType().equalsIgnoreCase(FrameworkConstants.SERVICE_TYPE_OPEN))?false:true;
		}
		return false;
	}

	private boolean isChannelAuthorized(String serviceName, String channelId) {
		
		AtomicBoolean hasAccess=new AtomicBoolean(false);
		Optional<List<Channel>> serviceChannelList=Optional.ofNullable(cacheManager.getServiceChannelList(serviceName));
		
		if(serviceChannelList.isPresent()) {
			serviceChannelList.get().forEach(channel->{
				if(channel.channelId().equalsIgnoreCase(channelId)) {
					hasAccess.set(true); 
					}
			});
				
		}
		return hasAccess.get();
	}

}
