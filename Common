package com.sbi.microservice.framework.services;

import com.sbi.microservice.framework.cache.CacheManager;
import com.sbi.microservice.framework.constant.FrameworkConstants;
import com.sbi.microservice.framework.exception.AccessException;
import com.sbi.microservice.framework.model.Access;
import com.sbi.microservice.framework.model.Channel;
import com.sbi.microservice.framework.model.Service;
import com.sbi.microservice.framework.repository.ServiceDAO;
import com.sbi.microservice.framework.services.access.AuthenticationProvider;
import com.sbi.microservice.framework.services.access.AuthenticationProviderFactory;
import com.sbi.microservice.framework.utils.FrameworkUtils;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class AccessVerifierTest {
    @InjectMocks
    private AccessVerifier accessVerifier;

    @Mock
    private ServiceDAO serviceDAO;

    @Mock
    private CacheManager cacheManager;

    @Mock
    private FrameworkUtils frameworkUtils;

    @Mock
    private HttpServletRequest request;
    
    @Mock
    private HttpServletResponse response;
    
    @Mock
    private AuthenticationProviderFactory authenticationProviderFactory;

    @Test
    void checkServiceAccess_WithDebugMethod_ShouldDenyAccess() throws AccessException {
        when(frameworkUtils.extractServiceName(any())).thenReturn("testService");
        when(request.getHeader(FrameworkConstants.CHANNELID)).thenReturn("channelId");
        when(request.getMethod()).thenReturn("DEBUG");
        
        Service service = new Service("serviceId","testService","serviceType","serviceDescription",
                "envDomain","version","encryptionAlgo","hashAlgo","rsaAlgo","rsaKeyPath",1,1,
                "status",List.of(),List.of(),"category");
        when(cacheManager.getService(anyString())).thenReturn(service);
        
        Optional<Access> result = accessVerifier.checkServiceAccess(request, response);
        assertTrue(result.isPresent());
        assertEquals(FrameworkConstants.ACCESS_DENIED, result.get().accessStatus());
        assertEquals(FrameworkConstants.ACCESS_METHOD_NOT_ALLOWED, result.get().accessDescription());
    }

    @Test
    void checkServiceAccess_ServiceNotInCache_ShouldReturnFalseForSecuredService() throws AccessException {
        when(frameworkUtils.extractServiceName(any())).thenReturn("nonCachedService");
        when(request.getHeader(FrameworkConstants.CHANNELID)).thenReturn("channelId");
        when(request.getMethod()).thenReturn("GET");
        when(cacheManager.getService(anyString())).thenReturn(null);
        
        Optional<Access> result = accessVerifier.checkServiceAccess(request, response);
        assertTrue(result.isPresent());
        assertEquals(FrameworkConstants.ACCESS_DENIED, result.get().accessStatus());
    }

    @Test
    void checkServiceAccess_OpenService_ShouldGrantAccess() throws AccessException {
        when(frameworkUtils.extractServiceName(any())).thenReturn("openService");
        when(request.getHeader(FrameworkConstants.CHANNELID)).thenReturn("channelId");
        when(request.getMethod()).thenReturn("GET");
        
        Service openService = new Service("serviceId","openService",FrameworkConstants.SERVICE_TYPE_OPEN,
                "serviceDescription","envDomain","version","encryptionAlgo","hashAlgo","rsaAlgo",
                "rsaKeyPath",1,1,"status",List.of(),List.of(),"category");
        when(cacheManager.getService(anyString())).thenReturn(openService);
        
        Optional<Access> result = accessVerifier.checkServiceAccess(request, response);
        assertTrue(result.isPresent());
        assertEquals(FrameworkConstants.ACCESS_GRANTED, result.get().accessStatus());
    }

    @Test
    void checkServiceAccess_SecuredServiceWithChannelAccess_ShouldCheckAuthentication() throws AccessException {
        when(frameworkUtils.extractServiceName(any())).thenReturn("securedService");
        when(request.getHeader(FrameworkConstants.CHANNELID)).thenReturn("authorizedChannel");
        when(request.getMethod()).thenReturn("POST");
        when(frameworkUtils.getAttribute(request, "userNameFromFilter")).thenReturn(Optional.of("testUser"));
        
        Service securedService = new Service("serviceId","securedService",FrameworkConstants.SERVICE_TYPE_SECURED,
                "serviceDescription","envDomain","version","encryptionAlgo","hashAlgo","rsaAlgo",
                "rsaKeyPath",1,1,"status",List.of(),List.of(),"category");
        when(cacheManager.getService(anyString())).thenReturn(securedService);
        
        Channel authorizedChannel = new Channel("securedService", "authorizedChannel","channelName","status");
        when(cacheManager.getServiceChannelList(anyString())).thenReturn(List.of(authorizedChannel));
        
        AuthenticationProvider authProvider = mock(AuthenticationProvider.class);
        when(authenticationProviderFactory.getProvider(anyString())).thenReturn(authProvider);
        
        Optional<Access> result = accessVerifier.checkServiceAccess(request, response);
        assertTrue(result.isPresent());
        // We can't verify authentication result without mocking it properly
    }

    @Test
    void checkServiceAccess_UnrecognizedChannel_ShouldDenyAccess() throws AccessException {
        when(frameworkUtils.extractServiceName(any())).thenReturn("securedService");
        when(request.getHeader(FrameworkConstants.CHANNELID)).thenReturn("unknownChannel");
        when(request.getMethod()).thenReturn("GET");
        
        Service securedService = new Service("serviceId","securedService",FrameworkConstants.SERVICE_TYPE_SECURED,
                "serviceDescription","envDomain","version","encryptionAlgo","hashAlgo","rsaAlgo",
                "rsaKeyPath",1,1,"status",List.of(),List.of(),"category");
        when(cacheManager.getService(anyString())).thenReturn(securedService);
        
        Channel authorizedChannel = new Channel("securedService", "authorizedChannel","channelName","status");
        when(cacheManager.getServiceChannelList(anyString())).thenReturn(List.of(authorizedChannel));
        
        Optional<Access> result = accessVerifier.checkServiceAccess(request, response);
        assertTrue(result.isPresent());
        assertEquals(FrameworkConstants.ACCESS_DENIED, result.get().accessStatus());
        assertEquals(FrameworkConstants.ACCESS_CHANNEL_NOT_AUTHORIZED, result.get().accessDescription());
    }

    @Test
    void checkServiceAccess_WithEmptyServiceName_ShouldThrowException() {
        when(frameworkUtils.extractServiceName(any())).thenReturn("");
        assertThrows(ConfigurationException.class, () -> accessVerifier.checkServiceAccess(request, response));
    }
}
