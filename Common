public boolean linkAccounts(String userName, String linkedUserName) throws DAOException {
        logger.info("linkAccounts(String userName, String linkedUserName)" + LoggingConstants.METHODBEGIN);
        if (logger.isDebugEnabled())
            logger.debug("username , linkedUserName : " + userName + " AND " + linkedUserName);
        logger.info("username , linkedUserName : " + userName + "AND" + linkedUserName);

        if (userName == null || linkedUserName == null || (userName.trim()).equals(DAOConstants.EMPTY)
                || (linkedUserName.trim()).equals(DAOConstants.EMPTY)) {
          DAOException.throwException(ErrorConstants.FATAL_EXCEPTION_ERRORCODE);
        }
        else {

            Map inParams = new HashMap();
            inParams.put(DAOConstants.USER_NAME, userName);
            inParams.put(DAOConstants.LINKED_USER_NAME, linkedUserName);

            List parameterList = new ArrayList();
            parameterList.add(new SqlParameter(DAOConstants.USER_NAME, Types.VARCHAR));
            parameterList.add(new SqlParameter(DAOConstants.LINKED_USER_NAME, Types.VARCHAR));
            parameterList.add(new SqlOutParameter(DAOConstants.STATUS, Types.VARCHAR));

            CallableStatementCreatorFactory statementFactory = new CallableStatementCreatorFactory(
                    "{call LINK_ACCOUNTS(?,?,?)}", parameterList);

            CallableStatementCreator callableStatement = statementFactory.newCallableStatementCreator(inParams);

            Map result = getJdbcTemplate().call(callableStatement, parameterList);
            String linkAccountStatus = (String) result.get(DAOConstants.STATUS);
            logger.info("Value Returned by Procedure" + linkAccountStatus);

            if (linkAccountStatus.equalsIgnoreCase("true")) {
                logger.info("linkAccounts(String userName, String linkedUserName)" + LoggingConstants.METHODEND);
                return true;
            }
            else {
                logger.info("Exception occured :");
               DAOException.throwException(ErrorConstants.FATAL_EXCEPTION_ERRORCODE);
            }
        }
       return false;
    }
	
By seeing the below code as reference can you please make the above code like the same way like try catch return the same above logic only should be there..
public Map<String, String> getCutOffTime(){

        logger.info("getCutOffTimeData() {}" , UtilsConstant.METHODBEGIN);
        Map<String, String> data = null;
        try {
            List<Map<String, String>> cutOffList = jdbcTemplate.query(SQLConstants.CUT_OFF_TIME_VALUE, new NameValueMasterDataRowMapper());
            data =  cutOffList.get(0);

            logger.info("data {}", data);

        } catch(DataAccessException ex) {
            logger.error("getCutOffTime() exception occured {}" ,ex.getMessage());
            throw new TechnicalException(UtilsConstant.CONNECTION_ESTABLISH,ErrorCodes.DB_ACCESS_FAILURE);
        }
        logger.info("getCutOffTimeData() {}" , UtilsConstant.METHODEND);
        return data;
    }
